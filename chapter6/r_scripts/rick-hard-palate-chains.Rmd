---
title: "Hard Palate shape influences on vowel production: single agent chains"
author: "Dan Dediu (with Rick Janssen & Scott Moisik)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    highlight: kate
    theme: flatly
    toc: yes
    toc_depth: 6
  pdf_document:
    toc: yes
    toc_depth: '6'
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, echo=FALSE, warning=FALSE, message=FALSE}
library(ggplot2);
library(ggfortify);
library(reshape2);
library(fpc);
library(factoextra);
library(cluster);
library(lme4);
library(lmerTest);
library(rgl);
library(shapes);
library(plyr);
library(dplyr);
library(parallel);

# Parameters controlling the rendering/computation:
show.exploratory.plots = FALSE;
compute.intervowel.dists = FALSE;

# Mapping between colors, hyoid base and colors (for the 3D interactive plots):
cols4vowels <- matrix(c(gray(0.5),gray(0.0),     # schwa
                        "lightblue","blue",      # a
                        "lightyellow","yellow",  # ae
                        "lawngreen","green4",    # i
                        "darkorange","firebrick" # u
                        ),
                      ncol=2, byrow=TRUE);
rownames(cols4vowels) <- c("schwa", "a", "ae", "i", "u");
cols4vowels2D <- alpha(c(gray(0.0), "blue", "yellow1", "green2", "firebrick2"),0.5); names(cols4vowels2D) <- c("schwa", "a", "ae", "i", "u");
cols4vowels2D.IPA <- cols4vowels2D; names(cols4vowels2D.IPA) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
cols4condition <- c("low"=alpha("deepskyblue1",0.25), "average"=alpha("royalblue2",0.25), "high"=alpha("blue3",0.25),               # artifical HPs
                          "A12m"=alpha(gray(0.2),0.25), "A73m"=alpha(gray(0.4),0.25), "A79m"=alpha(gray(0.6),0.25), "A87m"=alpha(gray(0.8),0.25)); # actual HPs

# Display significance stars:
print.signif.stars <- function(p, markdown=TRUE) ifelse(p < 0.001, ifelse(markdown,"\\*\\*\\*","***"), 
                                                        ifelse(p < 0.01, ifelse(markdown,"\\*\\*","**"), 
                                                               ifelse(p < 0.05, ifelse(markdown,"\\*","*"), "")))
# Auxiliary functions for pretty printing regression coefficients:
print.lm.coeffs.as.table <- function(m, show.R2=TRUE, markdown=TRUE, as.data.frame=FALSE)
{
  # Model summaries:
  s.lm <- summary(m); s.aov <- summary(aov(m))[[1]];
  # Extract the variables and their types:
  vars <- attr(m$terms, "dataClasses"); iv <- vars[1]; dvs <- vars[-1]; 
  # and the interactions:
  ints <- setdiff(trimws(rownames(s.aov)), c(names(dvs),"Residuals")); names(ints) <- ints; 
  ints <- vapply(strsplit(ints,":",fixed=TRUE), function(x) paste0(dvs[x[1]],":",dvs[x[2]]), character(1));
  predictors <- c(dvs, ints);
  tmp <- vapply(seq_along(predictors), function(i)
  {
    x <- predictors[i]; x.name <- names(predictors)[i];
    if( x == "logical" )
    {
      p <- s.lm$coefficients[paste0(x.name,"TRUE"),"Pr(>|t|)"];
      paste0(ifelse(markdown && p < 0.05,"*",""),
             sprintf("%.2g",s.lm$coefficients[paste0(x.name,"TRUE"),"Estimate"]), " (", sprintf("%.2g",p), print.signif.stars(p, markdown), ")",
             ifelse(markdown && p < 0.05,"*",""));
    } else if( x == "numeric" )
    {
      p <- s.lm$coefficients[x.name,"Pr(>|t|)"];
      paste0(ifelse(markdown && p < 0.05,"*",""),
             sprintf("%.2g",s.lm$coefficients[x.name,"Estimate"]), " (", sprintf("%.2g",p), print.signif.stars(p, markdown), ")",
             ifelse(markdown && p < 0.05,"*",""));
    } else if( length(grep("factor",x,fixed=TRUE))==1 )
    {
      p <- s.aov[trimws(rownames(s.aov))==x.name,"Pr(>F)"];
      paste0(ifelse(markdown && p < 0.05,"*",""),
             ".", " (", sprintf("%.2g",p), print.signif.stars(p, markdown), ")",
             ifelse(markdown && p < 0.05,"*",""));
    }
  }, character(1));
  names(tmp) <- sub(")","",sub("I(","",names(predictors),fixed=TRUE),fixed=TRUE); 
  if( markdown ) names(tmp) <- paste0("**",names(tmp),"**");
  # Add R^2:
  if(show.R2)
  {
    tmp <- c(tmp, sprintf("%.1f%%",100*s.lm$adj.r.squared)); 
    if( markdown )
    {
      names(tmp)[length(tmp)] <- "***adjusted R^2^***";
      tmp[length(tmp)] <- paste0("***",tmp[length(tmp)],"***");
    } else
    {
      names(tmp)[length(tmp)] <- "adjusted R^2";
    }
  }
  # Return value:
  if( as.data.frame )
  {
    df <- matrix(tmp, nrow=1); colnames(df) <- names(tmp); return (as.data.frame(df));
  } else
  {
    return (tmp);
  }
}

# http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
#
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

```{r load and pre-process original files, include=FALSE}
# read the results:
results <- read.table("./hard-palate-chains-20180104.csv", sep=",", header=TRUE, quote="", stringsAsFactors=FALSE);

# filter out the run that did not finish:
tmp <- ddply(results, .(replication, chain_gen), function(x) nrow(unique(x[,c("condition", "vowel")])));
tmp <- tmp[ tmp$V1 == 25, ]; # keep only those that have all 5 conditions and all 5 vowels complete
results <- merge(results, tmp, by=c("replication", "chain_gen"), all=FALSE); results <- results[,-ncol(results)]; # keep only full runs (and get rid of the extra column)
results <- results[ results$replication < 50, ]; # keep only the first 50 replications (for now)

# convert to factors and add new info:
results$condition <- factor(results$condition, levels=c("standard", "low_palate", "high_palate", "A87m", "A73m"));
# rename the HP levels:
levels(results$condition) <- c( "average", "low", "high", "A87m", "A73m" );
# the vowels:
results$vowel <- factor(results$vowel, levels=c("schwa", "a", "ae", "i", "u" ));
results <- cbind(results,
                 "F1.error"=(results$F1_elite - results$F1_target),
                 "F2.error"=(results$F2_elite - results$F2_target),
                 "F3.error"=(results$F3_elite - results$F3_target),
                 "F4.error"=(results$F4_elite - results$F4_target),
                 "F5.error"=(results$F5_elite - results$F5_target)); # add the errors between the target and the elite acoustics
results <- results[ order(results$condition, results$replication, results$chain_gen, results$vowel), ];

# Just the elite stuff:
results.elite <- results[, c("condition", "vowel", "replication", "chain_gen", "F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite", "F1.error", "F2.error", "F3.error", "F4.error", "F5.error",  "HX_elite", "HY_elite", "JA_elite", "LP_elite", "LD_elite", "TCX_elite", "TCY_elite", "TTX_elite", "TTY_elite", "TBX_elite", "TBY_elite", "generation") ];
names(results.elite) <- c("condition", "vowel", "replication", "chain_gen", "F1", "F2", "F3", "F4", "F5", "F1.error", "F2.error", "F3.error", "F4.error", "F5.error",  "HX", "HY", "JA", "LP", "LD", "TCX", "TCY", "TTX", "TTY", "TBX", "TBY", "generation");
#results.elite$condition <- factor(results.elite$condition, levels=c("average", "low", "high", "A87m", "A73m"));
#results.elite$vowel <- factor(results.elite$vowel, levels=c("schwa", "a", "ae", "i", "u" ));

# And just the targets:
results.target <- unique(results[,c("condition", "vowel", "replication", "chain_gen", "F1_target", "F2_target", "F3_target", "F4_target", "F5_target", "HX_target", "HY_target", "JA_target", "LP_target", "LD_target", "TCX_target", "TCY_target", "TTX_target", "TTY_target", "TBX_target", "TBY_target", "generation")]);
names(results.target) <- c("condition", "vowel", "replication", "chain_gen", "F1", "F2", "F3", "F4", "F5",  "HX", "HY", "JA", "LP", "LD", "TCX", "TCY", "TTX", "TTY", "TBX", "TBY", "generation");
#results.target$condition <- factor(results.target$condition, levels=c("average", "low", "high", "A87m", "A73m"));
#results.target$vowel <- factor(results.target$vowel, levels=c("schwa", "a", "ae", "i", "u" ));

if( !file.exists("./HP-chains-inter-vowel-dists.RData") )
{
  # Per replication inter-vowel distances:
  tmp <- unique(results[,c("condition", "replication", "chain_gen")]);
  vowel.pairs <- expand.grid("vowel1"=as.character(unique(results$vowel)), "vowel2"=as.character(unique(results$vowel)), stringsAsFactors=FALSE); vowel.pairs <- vowel.pairs[ vowel.pairs$vowel1 < vowel.pairs$vowel2, ]; vowel.pairs <- vowel.pairs[ order(vowel.pairs$vowel1, vowel.pairs$vowel2), ];
  intervowel.dists <- do.call(rbind, mclapply(1:nrow(tmp), function(i)
  {
    s <- results[ results$condition == tmp$condition[i] & results$replication == tmp$replication[i] & results$chain_gen == tmp$chain_gen[i], ];
    ret.val <- data.frame(s[1, c("condition", "replication", "chain_gen"), drop=FALSE], 
                          vowel.pairs, "vowel.pair"=paste0(vowel.pairs$vowel1,"-",vowel.pairs$vowel2),
                          do.call(rbind,lapply(1:nrow(vowel.pairs), function(j) 
                          {
                            s1 <- s[ s$vowel %in% c(vowel.pairs$vowel1[j],vowel.pairs$vowel2[j]), ];
                            return (data.frame("dist_target_F1F5"=as.numeric(dist(s1[, c("F1_target", "F2_target", "F3_target", "F4_target", "F5_target")])),
                                               "dist_elite_F1F5"= as.numeric(dist(s1[, c("F1_elite",  "F2_elite",  "F3_elite",  "F4_elite",  "F5_elite" )])),
                                               "dist_target_F1F2"=as.numeric(dist(s1[, c("F1_target", "F2_target")])),
                                               "dist_elite_F1F2"= as.numeric(dist(s1[, c("F1_elite",  "F2_elite" )]))));
                          })));
  }, mc.cores=4));
  #intervowel.dists$condition <- factor(intervowel.dists$condition, levels=c("average", "low", "high", "A87m", "A73m"));
  intervowel.dists$vowel1 <- factor(intervowel.dists$vowel1, levels=c("schwa", "a", "ae", "i", "u" ));
  intervowel.dists$vowel2 <- factor(intervowel.dists$vowel2, levels=c("schwa", "a", "ae", "i", "u" ));
  save(vowel.pairs, intervowel.dists, file="./HP-chains-inter-vowel-dists.RData", compress="xz");
} else
{
  load("./HP-chains-inter-vowel-dists.RData");
}

if( !file.exists("./HP-chains-procrustes-target-elite-dists.RData") )
{
  # Procrustes distances between the elite and target vowel systems:
  proc.target.elite.dists <- do.call(rbind, mclapply(1:nrow(tmp), function(i)
  {
    s <-  results[ results$condition == tmp$condition[i] & results$replication == tmp$replication[i] & results$chain_gen == tmp$chain_gen[i], ];
    s1 <- as.matrix(s[ , c("F1_target", "F2_target", "F3_target", "F4_target", "F5_target", "F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite")]); rownames(s1) <- s$vowel;
    z <-  results[ results$condition == tmp$condition[i] & results$replication == tmp$replication[i] & results$chain_gen == 0, ]; # the real (i.e., first generation) target
    z1 <- as.matrix(z[ , c("F1_target", "F2_target", "F3_target", "F4_target", "F5_target", "F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite")]); rownames(z1) <- z$vowel;
    ret.val <- data.frame(s[1, c("condition", "replication", "chain_gen"), drop=FALSE], 
                          "Proc.rmsd.prevgen"=procOPA(s1[,c("F1_target","F2_target","F3_target","F4_target","F5_target")], s1[,c("F1_elite","F2_elite","F3_elite","F4_elite","F5_elite")])$rmsd,
                          "Proc.rmsd.target" =procOPA(z1[,c("F1_target","F2_target","F3_target","F4_target","F5_target")], s1[,c("F1_elite","F2_elite","F3_elite","F4_elite","F5_elite")])$rmsd);
  }, mc.cores=4));
  #proc.target.elite.dists$condition <- factor(proc.target.elite.dists$condition, levels=c("average", "low", "high", "A87m", "A73m"));
  save(proc.target.elite.dists, file="./HP-chains-procrustes-target-elite-dists.RData", compress="xz");
} else
{
  load("./HP-chains-procrustes-target-elite-dists.RData");
}

# Long format collapsing formants and parameters:
results.long <- melt(results, 
                     id.vars=c("condition", "vowel", "replication", "chain_gen"),
                     measure.vars=c("F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite",
                                    "F1.error", "F2.error", "F3.error", "F4.error", "F5.error",
                                    "HX_elite", "HY_elite", "JA_elite", "LP_elite", "LD_elite", "TCX_elite", "TCY_elite", "TTX_elite", "TTY_elite", "TBX_elite", "TBY_elite", 
                                    "generation"),
                     variable.name="variable", value.name="value");
#results.long$condition <- factor(results.long$condition, levels=c("average", "low", "high", "A87m", "A73m"));
#results.long$vowel <- factor(results.long$vowel, levels=c("schwa", "a", "ae", "i", "u" ));
```


## Data description

Each sound is characterized by the first five formants *F1* -- *F5* as well as by the following 11 articulatory parameters:

  * *HX*, *HY*: **hyoid** position (horizontal and vertical),
  * *JA*: **jaw angle**,
  * *LP*: **lid protrusion**,
  * *LD*: **lip distance**,
  * *TCX*, *TCY*: **tongue body** position (horizontal and vertical),
  * *TTX*, *TTY*: **tongue tip** position (horizontal and vertical),
  * *TBX*, *TBY*: **tongue blade** position (horizontal and vertical).
  
Also relevant are the *condition* (i.e., hard palate shapes, including three "artifical" ones [extremely *low*, the *average* model in VTL, and extremely *high*] and one real participant in the *ArtiVarK* experiment), *vowel* (i, a, ae, schwa, and u), *replication*, and the *generation* when the best elite performance was reached.
For each sound, there's a *target* (acoustic and articulatory) the same across conditions and replications, and the actual best (or *elite*) realization in a given condition and replication, from which we also computed the squared error between the target the elite values for each of the *F1* -- *F5*.

For this run, there is also the particular generation in the chain a given agent belong to, *chain_gen*.

We have `r length(unique(results$condition))` hard palate shapes (or conditions) `r paste0("'",unique(results$condition),"'", collapse=", ")`, `r length(unique(results$replication))` replications for `r length(unique(results$chain_gen))` chain generations.

### Plotting vowels in the formant space

```{r echo=FALSE, message=FALSE}
d <- results;
levels(d$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$vowel))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F1 by (chain) generation, replication, condition and vowel."}
# F1 by chain_gen:
ggplot(d, aes(x=chain_gen, y=F1_elite, color=vowel)) + 
  geom_path() + 
  facet_grid(as.factor(replication) ~ condition, scales="free_y") +
  scale_color_manual(values=cols4vowels2D.IPA);
```

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=7, fig.cap="F1 by (chain) generation, condition and vowel with loess regressions across replications"}
ggplot(d, aes(x=chain_gen, y=F1_elite, color=replication)) + xlab("chain generation") + ylab("F1") + 
  geom_point(alpha=0.25, size=1.5) + geom_smooth(color="red") +
  facet_grid(vowel ~ condition, scales="free_y")
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$vowel))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F2 by (chain) generation, replication, condition and vowel."}
# F2 by chain_gen:
ggplot(d, aes(x=chain_gen, y=F2_elite, color=vowel)) + 
  geom_path() + 
  facet_grid(as.factor(replication) ~ condition, scales="free_y") +
  scale_color_manual(values=cols4vowels2D.IPA);
```

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=7, fig.cap="F2 by (chain) generation, condition and vowel with loess regressions across replications"}
ggplot(d, aes(x=chain_gen, y=F2_elite, color=replication)) + xlab("chain generation") + ylab("F2") + 
  geom_point(alpha=0.25, size=1.5) + geom_smooth(color="red") +
  facet_grid(vowel ~ condition, scales="free_y")
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$condition))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F1 x F2 scatterplots by replication and condition."}
# F1 x F2:
ggplot(d, aes(x=F2_elite, y=F1_elite, shape=vowel, fill=chain_gen, color=chain_gen)) + scale_y_reverse() + scale_x_reverse() +  
  geom_point(alpha=0.25, size=1.0) + 
  scale_shape_manual(values=21:25) +  
  facet_grid(as.factor(replication) ~ as.factor(condition));
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$condition))*2.5 + 1, fig.height=2.5+1, fig.cap="F1 x F2 scatterplots by condition (all replications are collapsed)."}
# F1 x F2:
ggplot(d, aes(x=F2_elite, y=F1_elite, shape=vowel, fill=chain_gen, color=chain_gen)) + 
  scale_y_reverse() + scale_x_reverse() + xlab("F2") + ylab("F1") +
  geom_point(alpha=0.25, size=1.0) + 
  scale_shape_manual(values=21:25) + scale_fill_continuous(name="chain generation") + scale_color_continuous(name="chain generation") +
  facet_grid(. ~ as.factor(condition));
```

```{r echo=FALSE, message=FALSE, fig.width=6, fig.height=5, fig.cap="F1 x F2 scatterplots by condition for the first chain generation only (all replications are collapsed)."}
# F1 x F2:
ggplot(d[d$chain_gen==0,], aes(x=F2_elite, y=F1_elite, shape=vowel, fill=condition, color=condition)) + 
  scale_y_reverse() + scale_x_reverse() + xlab("F2") + ylab("F1") +
  geom_point(alpha=0.25, size=1.5) + 
  scale_shape_manual(values=21:25);
```

```{r echo=FALSE, message=FALSE, fig.width=10, fig.height=10}
# Interactive 3D scatterplot:
mfrow3d(nr = 3, nc = 2, sharedMouse = TRUE);
for( i in levels(d$condition) )
{
  plot3d(-d$F2_elite[d$condition==i], d$chain_gen[d$condition==i], -d$F1_elite[d$condition==i], type="s", 
         main=paste0("Condition '",i,"'"), xlab="-F2", ylab="generation", zlab="-F1",
         sub="'schwa'=black 'a'=blue 'ae'=yellow 'i'=green 'u'=red",
         col=cols4vowels2D[d$vowel[d$condition==i]],
         size=1.0);
}
rglwidget();
mfrow3d(nr = 1, nc = 1); 
```


```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$vowel))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F3 by (chain) generation, replication, condition and vowel."}
# F3 by chain_gen:
ggplot(d, aes(x=chain_gen, y=F3_elite, color=vowel)) + 
  geom_path() + 
  facet_grid(as.factor(replication) ~ condition, scales="free_y") +
  scale_color_manual(values=cols4vowels2D.IPA);
```

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=7, fig.cap="F3 by (chain) generation, condition and vowel with loess regressions across replications"}
ggplot(d, aes(x=chain_gen, y=F3_elite, color=replication)) + xlab("chain generation") + ylab("F3") + 
  geom_point(alpha=0.25, size=1.5) + geom_smooth(color="red") +
  facet_grid(vowel ~ condition, scales="free_y")
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$vowel))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F4 by (chain) generation, replication, condition and vowel."}
# F4 by chain_gen:
ggplot(d, aes(x=chain_gen, y=F4_elite, color=vowel)) + 
  geom_path() + 
  facet_grid(as.factor(replication) ~ condition, scales="free_y") +
  scale_color_manual(values=cols4vowels2D.IPA);
```

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=7, fig.cap="F4 by (chain) generation, condition and vowel with loess regressions across replications"}
ggplot(d, aes(x=chain_gen, y=F4_elite, color=replication)) + xlab("chain generation") + ylab("F4") + 
  geom_point(alpha=0.25, size=1.5) + geom_smooth(color="red") +
  facet_grid(vowel ~ condition, scales="free_y")
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```

```{r echo=FALSE, message=FALSE, fig.width=length(unique(results$vowel))*2 + 1, fig.height=length(unique(results$replication))*2, fig.cap="F5 by (chain) generation, replication, condition and vowel."}
# F5 by chain_gen:
ggplot(d, aes(x=chain_gen, y=F5_elite, color=vowel)) + 
  geom_path() + 
  facet_grid(as.factor(replication) ~ condition, scales="free_y") +
  scale_color_manual(values=cols4vowels2D.IPA);
```

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=7, fig.cap="F5 by (chain) generation, condition and vowel with loess regressions across replications"}
ggplot(d, aes(x=chain_gen, y=F5_elite, color=replication)) + xlab("chain generation") + ylab("F5") + 
  geom_point(alpha=0.25, size=1.5) + geom_smooth(color="red") +
  facet_grid(vowel ~ condition, scales="free_y")
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```


```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=11, fig.cap="All formants by (chain) generation, condition and vowel with loess regressions across replications."}
d.melted <- melt(d, id.vars=c("replication", "chain_gen", "condition", "vowel"), measure.vars=c("F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite"), variable.name="formant");
ggplot(d.melted, aes(x=chain_gen, y=value, color=formant, group=formant)) + 
  geom_point(alpha=0.25, size=0.25) + geom_smooth(color="black", size=0.5, alpha=0.5, se=FALSE) +
  facet_grid(vowel ~ condition)
  #scale_color_manual(values=cols4vowels2D) + scale_shape_manual(values=21:25);
```


### Formants predicted by condition, vowel and chain generation

```{r vowel stats, echo=FALSE, message=FALSE, warning=FALSE}
d <- results;
#levels(d$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
```

**F1 and error**
```{r echo=FALSE, message=FALSE, warning=FALSE}
f1.lm <- lm(F1_elite ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
summary(aov(f1.lm)); TukeyHSD(aov(f1.lm), which=c("vowel","condition")); summary(f1.lm); 

f1e.lm <- lm(F1.error ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
summary(aov(f1e.lm)); TukeyHSD(aov(f1e.lm), which=c("vowel","condition")); summary(f1e.lm); 
```

**F2**
```{r echo=FALSE, message=FALSE, warning=FALSE}
f2.lm <- lm(F2_elite ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
summary(aov(f2.lm)); TukeyHSD(aov(f2.lm), which=c("vowel","condition")); summary(f2.lm); 

f2e.lm <- lm(F2.error ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
summary(aov(f2e.lm)); TukeyHSD(aov(f2e.lm), which=c("vowel","condition")); summary(f2e.lm); 
```

**F3**
```{r echo=FALSE, message=FALSE, warning=FALSE}
f3.lm <- lm(F3_elite ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
summary(aov(f3.lm)); TukeyHSD(aov(f3.lm), which=c("vowel","condition")); summary(f3.lm); 

f3e.lm <- lm(F3.error ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
summary(aov(f3e.lm)); TukeyHSD(aov(f3e.lm), which=c("vowel","condition")); summary(f3e.lm); 
```

**F4**
```{r echo=FALSE, message=FALSE, warning=FALSE}
f4.lm <- lm(F4_elite ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
summary(aov(f4.lm)); TukeyHSD(aov(f4.lm), which=c("vowel","condition")); summary(f4.lm); 

f4e.lm <- lm(F4.error ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
summary(aov(f4e.lm)); TukeyHSD(aov(f4e.lm), which=c("vowel","condition")); summary(f4e.lm); 
```

**F5**
```{r echo=FALSE, message=FALSE, warning=FALSE}
f5.lm <- lm(F5_elite ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
summary(aov(f5.lm)); TukeyHSD(aov(f5.lm), which=c("vowel","condition")); summary(f5.lm); 

f5e.lm <- lm(F5.error ~ condition + vowel + (condition : vowel) + replication + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
summary(aov(f5e.lm)); TukeyHSD(aov(f5e.lm), which=c("vowel","condition")); summary(f5e.lm); 
```

**Summarized**
```{r echo=FALSE, message=FALSE, warning=FALSE}
tmp <- t(do.call(rbind, lapply(list("F1"=f1.lm, "F1 error"=f1e.lm, "F2"=f2.lm, "F2 error"=f2e.lm, "F3"=f3.lm, "F3 error"=f3e.lm, "F4"=f4.lm, "F4 error"=f4e.lm, "F5"=f5.lm, "F5 error"=f5e.lm), 
                               function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of F1--F5 regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.cap="Predicted formants for each vowel per condition. (95% prediction intervals are too narrow to show.)"}
# For plotting, get rid of replication (ns anyway):
f1.lm <- lm(F1_elite ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
f2.lm <- lm(F2_elite ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
f3.lm <- lm(F3_elite ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
f4.lm <- lm(F4_elite ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
f5.lm <- lm(F5_elite ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
            data=d); 
f1.pred <- predict(f1.lm, f15.data <- expand.grid("condition"=levels(d$condition), 
                                                  "vowel"=levels(d$vowel),
                                                  "chain_gen"=min(d$chain_gen):max(d$chain_gen)), se.fit=TRUE, interval="confidence");
f2.pred <- predict(f2.lm, f15.data, se.fit=TRUE, interval="confidence");
f3.pred <- predict(f3.lm, f15.data, se.fit=TRUE, interval="confidence");
f4.pred <- predict(f4.lm, f15.data, se.fit=TRUE, interval="confidence");
f5.pred <- predict(f5.lm, f15.data, se.fit=TRUE, interval="confidence");
f15.data <- rbind(cbind(f15.data, "formant"="F1", "values"=f1.pred$fit[,"fit"], "CI95.lwr"=f1.pred$fit[,"lwr"], "CI95.upr"=f1.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F2", "values"=f2.pred$fit[,"fit"], "CI95.lwr"=f2.pred$fit[,"lwr"], "CI95.upr"=f2.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F3", "values"=f3.pred$fit[,"fit"], "CI95.lwr"=f3.pred$fit[,"lwr"], "CI95.upr"=f3.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F4", "values"=f4.pred$fit[,"fit"], "CI95.lwr"=f4.pred$fit[,"lwr"], "CI95.upr"=f4.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F5", "values"=f5.pred$fit[,"fit"], "CI95.lwr"=f5.pred$fit[,"lwr"], "CI95.upr"=f5.pred$fit[,"upr"]));
f15.data <- cbind(f15.data, "target"=unlist(mclapply(1:nrow(f15.data), function(i)
  {
    s <- which(results$condition == as.character(f15.data$condition[i]) & results$vowel == as.character(f15.data$vowel[i]));
    results[ s[1], paste0(f15.data$formant[i],"_target") ];
  }, mc.cores=4)));
#f15.data$condition <- factor(f15.data$condition, levels=levels(d$condition));
#f15.data$vowel     <- factor(f15.data$vowel,     levels=levels(d$vowel));
levels(f15.data$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
ggplot(f15.data, aes(x=chain_gen, y=values, color=vowel)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=vowel, fill=vowel), alpha=0.3) +
  #geom_point(aes(x=chain_gen, y=values, color=vowel, fill=vowel, shape=vowel), 
  #           data=pcart.data[ pcart.data$chain_gen %in% c(min(results.PCs.art$chain_gen),max(results.PCs.art$chain_gen)), ], 
  #           size=3, alpha=0.75) + 
  geom_hline(aes(yintercept=target, color=vowel), linetype="dashed", size=1.2) +
  scale_shape_manual(values=21:25) + scale_color_manual(values=cols4vowels2D.IPA) + scale_fill_manual(values=cols4vowels2D.IPA) +
  facet_grid(formant ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("formant values");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.cap="Predicted formants for each vowel per condition. (95% prediction intervals are too narrow to show.)"}
ggplot(f15.data, aes(x=chain_gen, y=values, color=formant)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=formant, fill=formant), alpha=0.3) +
  geom_hline(aes(yintercept=target, color=formant), linetype="dashed", size=1.2) +
  scale_shape_manual(values=21:25) +
  facet_grid(vowel ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("formant values");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.cap="Scaled predicted formants for each vowel per condition. (95% prediction intervals are not shown)."}
f15.data.ranges <- as.data.frame(f15.data %>% group_by(condition,vowel,formant) %>% summarize(min(CI95.lwr),max(CI95.upr)));
f15.data.scaled <- merge(f15.data, f15.data.ranges, all=TRUE);
f15.data.scaled$values   <- (f15.data.scaled$values   - f15.data.scaled$`min(CI95.lwr)`) / (f15.data.scaled$`max(CI95.upr)` - f15.data.scaled$`min(CI95.lwr)`);
f15.data.scaled$CI95.lwr <- (f15.data.scaled$CI95.lwr - f15.data.scaled$`min(CI95.lwr)`) / (f15.data.scaled$`max(CI95.upr)` - f15.data.scaled$`min(CI95.lwr)`);
f15.data.scaled$CI95.upr <- (f15.data.scaled$CI95.upr - f15.data.scaled$`min(CI95.lwr)`) / (f15.data.scaled$`max(CI95.upr)` - f15.data.scaled$`min(CI95.lwr)`);
f15.data.scaled$target   <- (f15.data.scaled$target   - f15.data.scaled$`min(CI95.lwr)`) / (f15.data.scaled$`max(CI95.upr)` - f15.data.scaled$`min(CI95.lwr)`);
ggplot(f15.data.scaled, aes(x=chain_gen, y=values, color=formant)) + 
  geom_line(size=2) + 
  #geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=formant, fill=formant), alpha=0.1) +
  geom_hline(aes(yintercept=target, color=formant), linetype="dashed", size=1.2) +
  scale_shape_manual(values=21:25) +
  facet_grid(vowel ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("formant values");
```


```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.cap="Predicted acoustic errors for each vowel per condition. (95% prediction intervals are too narrow to show.)"}
# For plotting, get rid of replication (ns anyway):
f1e.lm <- lm(F1.error ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
f2e.lm <- lm(F2.error ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
f3e.lm <- lm(F3.error ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
f4e.lm <- lm(F4.error ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
f5e.lm <- lm(F5.error ~ condition + vowel + (condition : vowel) + chain_gen + I(chain_gen^2) + 
                        (condition : vowel) + 
                        (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                        (chain_gen : condition) + (I(chain_gen^2) : condition), 
             data=d); 
f1.pred <- predict(f1e.lm, f15.data <- expand.grid("condition"=levels(d$condition), 
                                                   "vowel"=levels(d$vowel),
                                                   "chain_gen"=min(d$chain_gen):max(d$chain_gen)), se.fit=TRUE, interval="confidence");
f2.pred <- predict(f2e.lm, f15.data, se.fit=TRUE, interval="confidence");
f3.pred <- predict(f3e.lm, f15.data, se.fit=TRUE, interval="confidence");
f4.pred <- predict(f4e.lm, f15.data, se.fit=TRUE, interval="confidence");
f5.pred <- predict(f5e.lm, f15.data, se.fit=TRUE, interval="confidence");
f15.data <- rbind(cbind(f15.data, "formant"="F1", "values"=f1.pred$fit[,"fit"], "CI95.lwr"=f1.pred$fit[,"lwr"], "CI95.upr"=f1.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F2", "values"=f2.pred$fit[,"fit"], "CI95.lwr"=f2.pred$fit[,"lwr"], "CI95.upr"=f2.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F3", "values"=f3.pred$fit[,"fit"], "CI95.lwr"=f3.pred$fit[,"lwr"], "CI95.upr"=f3.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F4", "values"=f4.pred$fit[,"fit"], "CI95.lwr"=f4.pred$fit[,"lwr"], "CI95.upr"=f4.pred$fit[,"upr"]),
                  cbind(f15.data, "formant"="F5", "values"=f5.pred$fit[,"fit"], "CI95.lwr"=f5.pred$fit[,"lwr"], "CI95.upr"=f5.pred$fit[,"upr"]));
f15.data <- cbind(f15.data, "target"=unlist(mclapply(1:nrow(f15.data), function(i)
  {
  s <- which(results$condition == f15.data$condition[i] & results$vowel == f15.data$vowel[i]);
   results[ s[1], paste0(f15.data$formant[i],"_target") ];
  }, mc.cores=4)));
#f15.data$condition <- factor(f15.data$condition, levels=levels(d$condition));
#f15.data$vowel     <- factor(f15.data$vowel,     levels=levels(d$vowel));
levels(f15.data$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
ggplot(f15.data, aes(x=chain_gen, y=values, color=vowel)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=vowel, fill=vowel), alpha=0.3) +
  scale_shape_manual(values=21:25) + scale_color_manual(values=cols4vowels2D.IPA) + scale_fill_manual(values=cols4vowels2D.IPA) +
  facet_grid(formant ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("error");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=10, fig.cap="Predicted acoustic errors for each vowel per condition. (95% prediction intervals are too narrow to show.)"}
ggplot(f15.data, aes(x=chain_gen, y=values, color=formant)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=formant, fill=formant), alpha=0.3) +
  scale_shape_manual(values=21:25) + 
  facet_grid(vowel ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("error");
```


### Inter-vowel distances

```{r echo=FALSE, message=FALSE, fig.width=length(unique(intervowel.dists$condition))*2+1, fig.height=length(unique(intervowel.dists$vowel.pair))*2, fig.cap="Inter-vowel Euclidean distances (F1-F5) by (chain) generation."}
intervowel.dists <- intervowel.dists[ order(intervowel.dists$condition, intervowel.dists$vowel1, intervowel.dists$vowel2, intervowel.dists$replication, intervowel.dists$chain_gen), ];
levels(intervowel.dists$vowel.pair) <- c("[a]-[æ]", "[a]-[i]", "[a]-[ə]", "[a]-[u]", "[æ]-[i]", "[æ]-[ə]", "[æ]-[u]", "[i]-[ə]", "[i]-[u]", "[ə]-[u]");

ggplot(intervowel.dists, aes(x=chain_gen, y=dist_elite_F1F5, color=condition)) + xlab("chain generation") + ylab("inter-vowel Euclidean distance (F1-F5)") +
  geom_point(alpha=0.25, size=0.75) + geom_smooth(color="black") +
  facet_grid(vowel.pair ~ condition, scales="free_y");
```
```{r echo=FALSE, message=FALSE, fig.width=length(unique(intervowel.dists$condition))*2+1, fig.height=length(unique(intervowel.dists$vowel.pair))*2, fig.cap="Inter-vowel Euclidean distances (F1-F2) by (chain) generation."}
ggplot(intervowel.dists, aes(x=chain_gen, y=dist_elite_F1F2, color=condition)) + xlab("chain generation") + ylab("inter-vowel Euclidean distance (F1-F2)") +
  geom_point(alpha=0.25, size=0.75) + geom_smooth(color="black") +
  facet_grid(vowel.pair ~ condition, scales="free_y");
```

```{r inter-vowel distances F1-F5 (just the trends on same plot), echo=FALSE, message=FALSE, fig.width=2*3.5+1, fig.height=2*3+1, fig.cap="Inter-vowel Euclidean distances (F1-F5) by (chain) generation (trend lines only)."}
ggplot(intervowel.dists, aes(x=chain_gen, y=dist_elite_F1F5, color=condition)) + xlab("chain generation") + ylab("inter-vowel Euclidean distance (F1-F5)") +
  geom_point(alpha=0.0, size=0.0) + geom_smooth(alpha=0.50) +
  facet_wrap( ~ vowel.pair, scales="free_y");
```

```{r inter-vowel distances F1-F2 (just the trends on same plot), echo=FALSE, message=FALSE, fig.width=2*3.5+1, fig.height=2*3+1, fig.cap="Inter-vowel Euclidean distances (F1-F2) by (chain) generation (trend lines only)."}
ggplot(intervowel.dists, aes(x=chain_gen, y=dist_elite_F1F2, color=condition)) + xlab("chain generation") + ylab("inter-vowel Euclidean distance (F1-F2)") +
  geom_point(alpha=0.0, size=0.0) + geom_smooth(alpha=0.50) +
  facet_wrap( ~ vowel.pair, scales="free_y");
```

**F1--F5**
```{r echo=FALSE, message=FALSE, warning=FALSE}
ive15.lm <- lm(dist_elite_F1F5 ~ condition + vowel.pair + chain_gen + I(chain_gen^2) + replication + 
                                 (condition : vowel.pair) + (condition : chain_gen) + (condition : I(chain_gen^2)) + (vowel.pair : chain_gen) + (vowel.pair : I(chain_gen^2)),  data=intervowel.dists); 
summary(aov(ive15.lm)); TukeyHSD(aov(ive15.lm), which=c("condition","vowel.pair")); summary(ive15.lm); 
```

**F1--F2**
```{r echo=FALSE, message=FALSE, warning=FALSE}
ive12.lm <- lm(dist_elite_F1F2 ~ condition + vowel.pair + chain_gen + I(chain_gen^2) + replication + 
                                 (condition : vowel.pair) + (condition : chain_gen) + (condition : I(chain_gen^2)) + (vowel.pair : chain_gen) + (vowel.pair : I(chain_gen^2)),  data=intervowel.dists); 
summary(aov(ive12.lm)); TukeyHSD(aov(ive12.lm), which=c("condition","vowel.pair")); summary(ive12.lm); 
```

**Summarized**
```{r echo=FALSE, message=FALSE, warning=FALSE}
tmp <- t(do.call(rbind, lapply(list("Dist(F1-F5)"=ive15.lm, "Dist(F1-F2)"=ive12.lm), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of intervowel distance regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=12, fig.cap="Inter-vowel distances (F1-F5) by condition, vowel pairs, and chain generation (with 95%CI and target)."}
# For plotting, get rid of replication (ns anyway):
ive15.lm <- lm(dist_elite_F1F5 ~ condition + vowel.pair + chain_gen + I(chain_gen^2) + 
                                 (condition : vowel.pair) + (condition : chain_gen) + (condition : I(chain_gen^2)) + (vowel.pair : chain_gen) + (vowel.pair : I(chain_gen^2)),  data=intervowel.dists); 
d15.pred <- predict(ive15.lm, d15.data <- expand.grid("condition"=levels(intervowel.dists$condition), 
                                                     "vowel.pair"=levels(intervowel.dists$vowel.pair),
                                                     "chain_gen"=min(d$chain_gen):max(d$chain_gen)), se.fit=TRUE, interval="confidence");
d15.data <- cbind(d15.data, "ivd15"=d15.pred$fit[,"fit"], "CI95.lwr"=d15.pred$fit[,"lwr"], "CI95.upr"=d15.pred$fit[,"upr"],
                  "vowel1"=vapply(strsplit(as.character(d15.data$vowel.pair),"-",fixed=TRUE), function(x) x[[1]], character(1)),
                  "vowel2"=vapply(strsplit(as.character(d15.data$vowel.pair),"-",fixed=TRUE), function(x) x[[2]], character(1)));
#d15.data$condition <- factor(d15.data$condition, levels=c("average", "low", "high", "A87m", "A73m"));
#d15.data$vowel1 <- factor(d15.data$vowel1, levels=c("schwa", "a", "ae", "i", "u" ));
#d15.data$vowel2 <- factor(d15.data$vowel2, levels=c("schwa", "a", "ae", "i", "u" ));
ggplot(d15.data, aes(x=chain_gen, y=ivd15, color=condition)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr), alpha=0.3) +
  scale_shape_manual(values=21:25)  +
  facet_grid(vowel.pair ~ condition, scales="free_y") + 
  xlab("generation (chains)") + ylab("inter-vowel Euclidean distance (F1-F5)");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=12, fig.cap="Inter-vowel distances (F1-F2) by condition, vowel pairs, and chain generation (with 95%CI and target)."}
# For plotting, get rid of replication (ns anyway):
ive12.lm <- lm(dist_elite_F1F2 ~ condition + vowel.pair + chain_gen + I(chain_gen^2) + 
                                 (condition : vowel.pair) + (condition : chain_gen) + (condition : I(chain_gen^2)) + (vowel.pair : chain_gen) + (vowel.pair : I(chain_gen^2)),  data=intervowel.dists); 
d12.pred <- predict(ive12.lm, d12.data <- expand.grid("condition"=levels(intervowel.dists$condition), 
                                                     "vowel.pair"=levels(intervowel.dists$vowel.pair),
                                                     "chain_gen"=min(d$chain_gen):max(d$chain_gen)), se.fit=TRUE, interval="confidence");
d12.data <- cbind(d12.data, "ivd12"=d12.pred$fit[,"fit"], "CI95.lwr"=d12.pred$fit[,"lwr"], "CI95.upr"=d12.pred$fit[,"upr"],
                  "vowel1"=vapply(strsplit(as.character(d12.data$vowel.pair),"-",fixed=TRUE), function(x) x[[1]], character(1)),
                  "vowel2"=vapply(strsplit(as.character(d12.data$vowel.pair),"-",fixed=TRUE), function(x) x[[2]], character(1)));
#d12.data$condition <- factor(d12.data$condition, levels=c("average", "low", "high", "A87m", "A73m"));
#d12.data$vowel1 <- factor(d12.data$vowel1, levels=c("schwa", "a", "ae", "i", "u" ));
#d12.data$vowel2 <- factor(d12.data$vowel2, levels=c("schwa", "a", "ae", "i", "u" ));
ggplot(d12.data, aes(x=chain_gen, y=ivd12, color=condition)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr), alpha=0.3) +
  scale_shape_manual(values=21:25)  +
  facet_grid(vowel.pair ~ condition, scales="free_y") + 
  xlab("generation (chains)") + ylab("inter-vowel Euclidean distance (F1-F2)");
```


### Procrustes distances between vowel systems

**To previous generation**
```{r echo=FALSE, message=FALSE, warning=FALSE}
pdpg.lm <- lm(Proc.rmsd.prevgen ~ condition + chain_gen + I(chain_gen^2) + replication + 
                                  (condition : chain_gen) + (condition : I(chain_gen^2)),  data=proc.target.elite.dists); 
summary(aov(pdpg.lm)); TukeyHSD(aov(pdpg.lm), which=c("condition")); summary(pdpg.lm); 
```

**To original target**
```{r echo=FALSE, message=FALSE, warning=FALSE}
pdot.lm <- lm(Proc.rmsd.target ~  condition + chain_gen + I(chain_gen^2) + replication + 
                                  (condition : chain_gen) + (condition : I(chain_gen^2)),  data=proc.target.elite.dists); 
summary(aov(pdot.lm)); TukeyHSD(aov(pdot.lm), which=c("condition")); summary(pdot.lm); 
```

**Summarized**
```{r echo=FALSE, message=FALSE, warning=FALSE}
tmp <- t(do.call(rbind, lapply(list("To previous generation"=pdpg.lm, "To original target"=pdot.lm), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of Procrustes distance regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```


```{r procrustes distances to previous, echo=FALSE, message=FALSE, fig.width=5, fig.height=6.5, fig.cap="Procrustes distances to previous generation"}
proc.target.elite.dists <- proc.target.elite.dists[ order(proc.target.elite.dists$condition, proc.target.elite.dists$replication, proc.target.elite.dists$chain_gen), ];

ggplot(proc.target.elite.dists, aes(x=chain_gen, y=Proc.rmsd.prevgen, color=replication)) + xlab("chain generation") + ylab("Procrustes distance") +
  geom_point(alpha=0.25, size=1.0) + geom_smooth(color="red") + 
  facet_wrap(~ condition, ncol=2);
```

```{r procrustes distances to targets, echo=FALSE, message=FALSE, fig.width=5, fig.height=6.5, fig.cap="Procrustes distances to original target"}
ggplot(proc.target.elite.dists, aes(x=chain_gen, y=Proc.rmsd.target, color=replication)) + xlab("chain generation") + ylab("Procrustes distance") +
  geom_point(alpha=0.25, size=1.0) + geom_smooth(color="red") +
  facet_wrap(~ condition, ncol=2);
```


## Principal Component Analysis

```{r PCs, echo=FALSE, fig.width=12, fig.height=12, warning=FALSE}
PCs <- prcomp( ~ F1 + F2 + F3 + F4 + F5 + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen, data=results.elite, scale=TRUE);
#summary(PCs); 

multiplot(plotlist=list(fviz_screeplot(PCs, main="Screeplot of the elite PCs"), 
                        fviz_contrib(PCs, choice = "var", axes = 2,
                                     fill=c("steelblue","lightsalmon")[as.numeric(PCs$rotation[order(abs(PCs$rotation[,"PC2"]),decreasing=TRUE),"PC2"] < 0)+1]) + 
                          ggtitle("Variable contributions on PC2"),
                        fviz_contrib(PCs, choice = "var", axes = 1,
                                     fill=c("steelblue","lightsalmon")[as.numeric(PCs$rotation[order(abs(PCs$rotation[,"PC1"]),decreasing=TRUE),"PC1"] < 0)+1]) + 
                          ggtitle("Variable contributions on PC1"),
                        fviz_pca_var(PCs, axes=c(1,2), col.var="contrib", title="Variable contributions on PC1 & PC2")), 
          cols=2);
```
```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=7}
d1 <- cbind(results.elite, PCs$x[,c("PC1","PC2","PC3")]);
d1.means <- aggregate(. ~ condition + vowel, d1[,c("vowel","condition","PC1","PC2","PC3")], mean);
levels(d1$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");

# Scatterplots:
# PC1 x PC2:
ggplot(d1, aes(x=PC1, y=PC2, shape=vowel, fill=chain_gen, color=chain_gen)) +  
  geom_point(alpha=0.25, size=1.5) + 
  scale_shape_manual(values=21:25) + #scale_fill_manual(values=cols4vowels2D) + scale_color_manual(values=cols4vowels2D) +  
  facet_grid(vowel ~ as.factor(condition), scales="fixed");
```

```{r echo=FALSE, message=FALSE, fig.width=10, fig.height=10}
# Interactive 3D scatterplot:
mfrow3d(nr = 3, nc = 2, sharedMouse = TRUE);
for( i in levels(d$condition) )
{
  plot3d(d1$PC1[d1$condition==i], d1$chain_gen[d1$condition==i], d1$PC2[d1$condition==i], type="s", 
         main=paste0("Condition '",i,"'"), xlab="PC1", ylab="generation", zlab="PC2",
         sub="'schwa'=black 'a'=blue 'ae'=yellow 'i'=green 'u'=red",
         col=cols4vowels2D[d1$vowel[d1$condition==i]],
         size=1.0);
}
rglwidget();
mfrow3d(nr = 1, nc = 1); 
```


## Stats

```{r echo=FALSE}
# Add the principal components and error to target to the data:
results.PCs <- cbind(results.elite, 
                     PCs$x, 
                     "F1.err"=(results$F1_elite - results$F1_target),
                     "F2.err"=(results$F2_elite - results$F2_target),
                     "F3.err"=(results$F3_elite - results$F3_target),
                     "F4.err"=(results$F4_elite - results$F4_target),
                     "F5.err"=(results$F5_elite - results$F5_target),
                     "acoustic.err"=sqrt((results$F1_target - results$F1_elite)^2 + 
                                           (results$F2_target - results$F2_elite)^2 + 
                                           (results$F3_target - results$F3_elite)^2 + 
                                           (results$F4_target - results$F4_elite)^2 + 
                                           (results$F5_target - results$F5_elite)^2));
#results.PCs$condition <- as.factor(results.PCs$condition); contrasts(results.PCs$condition) <- contr.sum(length(levels(results.PCs$condition)));
#results.PCs$vowel <- as.factor(results.PCs$vowel); contrasts(results.PCs$vowel) <- contr.sum(length(levels(results.PCs$vowel)));
results.PCs$condition <- relevel(as.factor(results.PCs$condition), ref="average");
results.PCs$vowel <- relevel(as.factor(results.PCs$vowel), ref="schwa");
```

### F1 -- F5 (and errors)

***F1***

```{r echo=FALSE, warning=FALSE, message=FALSE}
# F1:
f1.m0 <- lm(F1 ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f1.m0); TukeyHSD(aov(f1.m0), which=c("vowel","condition")); summary(f1.m0);

# F1 error:
f1e.m0 <- lm(F1.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f1e.m0); TukeyHSD(aov(f1e.m0), which=c("vowel","condition")); summary(f1e.m0);
```

***F2***

```{r echo=FALSE, warning=FALSE, message=FALSE}
# F2:
f2.m0 <- lm(F2 ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f2.m0); TukeyHSD(aov(f2.m0), which=c("vowel","condition")); summary(f2.m0);

# F2 error:
f2e.m0 <- lm(F2.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f2e.m0); TukeyHSD(aov(f2e.m0), which=c("vowel","condition")); summary(f2e.m0);
```

***F3***

```{r echo=FALSE, warning=FALSE, message=FALSE}
# F3:
f3.m0 <- lm(F3 ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f3.m0); TukeyHSD(aov(f3.m0), which=c("vowel","condition")); summary(f3.m0);

# F3 error:
f3e.m0 <- lm(F3.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f3e.m0); TukeyHSD(aov(f3e.m0), which=c("vowel","condition")); summary(f3e.m0);
```

***F4***

```{r echo=FALSE, warning=FALSE, message=FALSE}
# F4:
f4.m0 <- lm(F4 ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f4.m0); TukeyHSD(aov(f4.m0), which=c("vowel","condition")); summary(f4.m0);

# F4 error:
f4e.m0 <- lm(F4.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f4e.m0); TukeyHSD(aov(f4e.m0), which=c("vowel","condition")); summary(f4e.m0);
```

***F5***

```{r echo=FALSE, warning=FALSE, message=FALSE}
# F5:
f5.m0 <- lm(F5 ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f5.m0); TukeyHSD(aov(f5.m0), which=c("vowel","condition")); summary(f5.m0);

# F5 error:
f5e.m0 <- lm(F5.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                 condition : vowel + 
                 HX : vowel + HY : vowel + JA : vowel + LP : vowel + LD : vowel + TCX : vowel + TCY : vowel + TTX : vowel + TTY : vowel + TBX : vowel + TBY : vowel, 
            data=results.PCs); anova(f5e.m0); TukeyHSD(aov(f5e.m0), which=c("vowel","condition")); summary(f5e.m0);
```


***Summaries for F1 -- F5***

```{r echo=FALSE, message=FALSE, warning=FALSE}
tmp <- t(do.call(rbind, lapply(list("F1"=f1.m0, "F1.err"=f1e.m0, "F2"=f2.m0, "F2.err"=f2e.m0, "F3"=f3.m0, "F3.err"=f3e.m0, "F4"=f4.m0, "F4.err"=f4e.m0, "F5"=f5.m0, "F5.err"=f5e.m0), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of F1--F5 regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```

### PC1 & PC2

```{r echo=FALSE, warning=FALSE, message=FALSE}
# PC1:
pc1.m0 <- lm(PC1 ~ condition + vowel + replication + chain_gen + I(chain_gen^2) + (condition : vowel), data=results.PCs); 
anova(pc1.m0); TukeyHSD(aov(pc1.m0), which=c("vowel","condition")); summary(pc1.m0); # the best model

# PC2:
pc2.m0 <- lm(PC2 ~ condition + vowel + replication + chain_gen + I(chain_gen^2) + (condition : vowel), data=results.PCs); 
anova(pc2.m0); TukeyHSD(aov(pc2.m0), which=c("vowel","condition")); summary(pc2.m0); # the best model

# Summaries:
tmp <- t(do.call(rbind, lapply(list("PC1"=pc1.m0, "PC2"=pc2.m0), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of PC1 & PC2 regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=10, fig.cap="Predicted acoustic errors for each vowel per condition. (95% prediction intervals are too narrow to show.)"}
# For plotting, get rid of replication (ns anyway):
pc1.m0 <- lm(PC1 ~ condition + vowel + chain_gen + I(chain_gen^2) + (condition : vowel), data=results.PCs); 
pc2.m0 <- lm(PC2 ~ condition + vowel + chain_gen + I(chain_gen^2) + (condition : vowel), data=results.PCs); 
pc1.pred <- predict(pc1.m0, pcs.data <- expand.grid("condition"=levels(d$condition), 
                                                    "vowel"=levels(d$vowel),
                                                    "chain_gen"=min(d$chain_gen):max(d$chain_gen)), se.fit=TRUE, interval="confidence");
pc2.pred <- predict(pc2.m0, pcs.data, se.fit=TRUE, interval="confidence");
pcs.data <- rbind(cbind(pcs.data, "formant"="PC1", "values"=pc1.pred$fit[,"fit"], "CI95.lwr"=pc1.pred$fit[,"lwr"], "CI95.upr"=pc1.pred$fit[,"upr"]),
                  cbind(pcs.data, "formant"="PC2", "values"=pc2.pred$fit[,"fit"], "CI95.lwr"=pc2.pred$fit[,"lwr"], "CI95.upr"=pc2.pred$fit[,"upr"]));
pcs.data$condition <- factor(pcs.data$condition, levels=levels(d$condition));
pcs.data$vowel     <- factor(pcs.data$vowel,     levels=levels(d$vowel));
levels(pcs.data$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
ggplot(pcs.data, aes(x=chain_gen, y=values, color=vowel)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=vowel, fill=vowel), alpha=0.3) +
  scale_shape_manual(values=21:25) + scale_color_manual(values=cols4vowels2D.IPA) + scale_fill_manual(values=cols4vowels2D.IPA) +
  facet_grid(formant ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab("generation (chains)") + ylab("error");
```


### Overall acoustic error over F1 -- F5

```{r echo=FALSE, warning=FALSE, message=FALSE}
err.m0 <- lm(acoustic.err ~ condition + vowel + replication + HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen + I(chain_gen^2) +
                            (condition : vowel) + 
                            (HX : vowel) + (HY : vowel) + (JA : vowel) + (LP : vowel) + (LD : vowel) + (TCX : vowel) + (TCY : vowel) + (TTX : vowel) + (TTY : vowel) + (TBX : vowel) + (TBY : vowel), 
             data=results.PCs); anova(err.m0);  TukeyHSD(aov(err.m0), which=c("vowel","condition"));summary(err.m0);

# Summaries:
tmp <- t(do.call(rbind, lapply(list("F1-F5.err"=err.m0), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of F1-F5 error regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```


### PCA of articulatory parameters only

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=7, warning=FALSE}
# Make sure the levels are similar across all plots:
tmp <- results.PCs;
tmp$condition <- factor(tmp$condition, levels=c("low", "average", "high", "A87m"));
tmp$vowel <- factor(tmp$vowel, levels=c("schwa", "a", "ae", "i", "u" ));
PCs.art <- prcomp( ~ HX + HY + JA + LP + LD + TCX + TCY + TTX + TTY + TBX + TBY + chain_gen, data=tmp, scale=TRUE);

multiplot(plotlist=list(fviz_screeplot(PCs.art, main="Screeplot of the elite PCs"),
                        fviz_contrib(PCs.art, choice = "var", axes = 2,
                                     fill=c("steelblue","lightsalmon")[as.numeric(PCs.art$rotation[order(abs(PCs.art$rotation[,"PC2"]),decreasing=TRUE),"PC2"] < 0)+1]) +
                          ggtitle("Variable contributions on PC2"),
                        fviz_contrib(PCs.art, choice = "var", axes = 1,
                                     fill=c("steelblue","lightsalmon")[as.numeric(PCs.art$rotation[order(abs(PCs.art$rotation[,"PC1"]),decreasing=TRUE),"PC1"] < 0)+1]) +
                          ggtitle("Variable contributions on PC1"),
                        fviz_pca_var(PCs, axes=c(1,2), col.var="contrib", title="Variable contributions on PC1 & PC2")),
          cols=2);
```
```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=7}
results.PCs.art <- cbind(results.PCs[,1:25], PCs.art$x);

# PC1 x PC2:
ggplot(results.PCs.art, aes(x=PC1, y=PC2, shape=vowel, fill=chain_gen, color=chain_gen)) +  
  geom_point(alpha=0.25, size=1.5) + 
  scale_shape_manual(values=21:25, labels=c("schwa"="[ə]", "a"="[a]", "ae"="[æ]", "i"="[i]", "u"="[u]")) + #scale_fill_manual(values=cols4vowels2D) + scale_color_manual(values=cols4vowels2D) +  
  facet_grid(vowel ~ as.factor(condition), labeller=labeller("vowel"=c("schwa"="[ə]", "a"="[a]", "ae"="[æ]", "i"="[i]", "u"="[u]"))) +  
  ggtitle("Vowels in PC1 x PC2 in sequence by condition");
```

```{r echo=FALSE, message=FALSE, fig.width=10, fig.height=10}
# Interactive 3D scatterplot:
mfrow3d(nr = 3, nc = 2, sharedMouse = TRUE);
for( i in levels(results.PCs.art$condition) )
{
  plot3d(results.PCs.art$PC1[results.PCs.art$condition==i], results.PCs.art$chain_gen[results.PCs.art$condition==i], results.PCs.art$PC2[results.PCs.art$condition==i], type="s", 
         main=paste0("Condition '",i,"'"), xlab="PC1", ylab="generation", zlab="PC2",
         sub="'schwa'=black 'a'=blue 'ae'=yellow 'i'=green 'u'=red",
         col=cols4vowels2D[results.PCs.art$vowel[results.PCs.art$condition==i]],
         size=1.0);
}
rglwidget();
mfrow3d(nr = 1, nc = 1); 
```


```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=7}
# PC1:
pc1.art.m0 <- lm(PC1 ~ condition + vowel + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
                 data=results.PCs.art); anova(pc1.art.m0); summary(pc1.art.m0);

# PC2:
pc2.art.m0 <- lm(PC2 ~ condition + vowel + replication + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
                 data=results.PCs.art); anova(pc2.art.m0); summary(pc2.art.m0);

# Summaries:
tmp <- t(do.call(rbind, lapply(list("PC1"=pc1.art.m0, "PC2"=pc2.art.m0), function(m) print.lm.coeffs.as.table(m) )));
tmp <- cbind("DVs, interactions & R^2^"=rownames(tmp), tmp);
knitr::kable(tmp, row.names=FALSE, align="r", caption="Summary of articulatory PC1 & PC2 regressions with betas (for non-factor DVs and '.' for factors), *p*-values, and adjusted R^2^. Interactions are denoted by ':'.");
```
```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=7, fig.cap="Regression of articulatory PCs on condition, vowel and generation (with 95%CI)."}
# For plotting, get rid of replication (ns anyway):
pc1.art.m0 <- lm(PC1 ~ condition + vowel + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
                 data=results.PCs.art); anova(pc1.art.m0); summary(pc1.art.m0);
pc2.art.m0 <- lm(PC2 ~ condition + vowel + chain_gen + I(chain_gen^2) + 
                       (condition : vowel) + 
                       (chain_gen : vowel) + (I(chain_gen^2) : vowel) + 
                       (chain_gen : condition) + (I(chain_gen^2) : condition), 
                 data=results.PCs.art); anova(pc2.art.m0); summary(pc2.art.m0);
pc1art.pred <- predict(pc1.art.m0, pcart.data <- expand.grid("condition"=levels(results.PCs.art$condition), 
                                                             "vowel"=levels(results.PCs.art$vowel),
                                                             "chain_gen"=min(results.PCs.art$chain_gen):max(results.PCs.art$chain_gen)), se.fit=TRUE, interval="confidence");
pc2art.pred <- predict(pc2.art.m0, pcart.data, se.fit=TRUE, interval="confidence");
pcart.data <- rbind(cbind(pcart.data, "PC"="articulatory PC1", "values"=pc1art.pred$fit[,"fit"], "CI95.lwr"=pc1art.pred$fit[,"lwr"], "CI95.upr"=pc1art.pred$fit[,"upr"]),
                    cbind(pcart.data, "PC"="articulatory PC2", "values"=pc2art.pred$fit[,"fit"], "CI95.lwr"=pc2art.pred$fit[,"lwr"], "CI95.upr"=pc2art.pred$fit[,"upr"]));
pcart.data$condition <- factor(pcart.data$condition, levels=levels(results.PCs.art$condition));
pcart.data$vowel     <- factor(pcart.data$vowel,     levels=levels(results.PCs.art$vowel));
levels(pcart.data$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");
ggplot(pcart.data, aes(x=chain_gen, y=values, color=vowel)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=CI95.lwr, ymax=CI95.upr, color=vowel, fill=vowel), alpha=0.3) +
  scale_shape_manual(values=21:25) + scale_color_manual(values=cols4vowels2D.IPA) + scale_fill_manual(values=cols4vowels2D.IPA) +
  facet_grid(PC ~ condition, scales="free_y") + 
  theme(axis.text.x=element_text(angle=90,hjust=1));
```



## Compare input scaling and non-scaling in the neural network

Here we compare the input scaling and non-scaling data for the "average" hard palate shape in a single agent.

```{r echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
results.scaled <- read.table("./hard-palate-shape-20170820.csv", sep=",", header=TRUE, quote="", stringsAsFactors=FALSE);
results.scaled$vowel <- factor(results.scaled$vowel, levels=c("schwa", "a", "ae", "i", "u" ));
results.scaled <- cbind(results.scaled,
                        "F1.error"=(results.scaled$F1_target - results.scaled$F1_elite)^2,
                        "F2.error"=(results.scaled$F2_target - results.scaled$F2_elite)^2,
                        "F3.error"=(results.scaled$F3_target - results.scaled$F3_elite)^2,
                        "F4.error"=(results.scaled$F4_target - results.scaled$F4_elite)^2,
                        "F5.error"=(results.scaled$F5_target - results.scaled$F5_elite)^2); # add the errors between the target and the elite acoustics

results.nonscaled <- read.table("./hard-palate-shape-20170710.csv", sep=",", header=TRUE, quote="", stringsAsFactors=FALSE);
results.nonscaled <- results.nonscaled[ results.nonscaled$condition == "standard", ];
results.nonscaled$vowel <- factor(results.nonscaled$vowel, levels=c("schwa", "a", "ae", "i", "u" ));
results.nonscaled <- cbind(results.nonscaled,
                           "F1.error"=(results.nonscaled$F1_elite - results.nonscaled$F1_target),
                           "F2.error"=(results.nonscaled$F2_elite - results.nonscaled$F2_target),
                           "F3.error"=(results.nonscaled$F3_elite - results.nonscaled$F3_target),
                           "F4.error"=(results.nonscaled$F4_elite - results.nonscaled$F4_target),
                           "F5.error"=(results.nonscaled$F5_elite - results.nonscaled$F5_target)); # add the errors between the target and the elite acoustics



# Combine with the "standard" from the unscaled data:
results.merged <- merge(results.scaled, results.nonscaled, by=c("condition","vowel","replication"), suffixes=c(".sc",".nsc"));

# # Sanity checks:
# cor.test(results.merged$F1_target.sc, results.merged$F1_target.nsc);
# cor.test(results.merged$F2_target.sc, results.merged$F2_target.nsc);
# cor.test(results.merged$F3_target.sc, results.merged$F3_target.nsc);
# cor.test(results.merged$F4_target.sc, results.merged$F4_target.nsc);
# cor.test(results.merged$F5_target.sc, results.merged$F5_target.nsc);
```

Independent samples t-tests comparing the scaled and non-scaled elite formants ar all non-significant:
```{r echo=FALSE, warning=FALSE, message=FALSE}
t.test(results.merged$F1_elite.sc, results.merged$F1_elite.nsc, paired=FALSE);
t.test(results.merged$F2_elite.sc, results.merged$F2_elite.nsc, paired=FALSE);
t.test(results.merged$F3_elite.sc, results.merged$F3_elite.nsc, paired=FALSE);
t.test(results.merged$F4_elite.sc, results.merged$F4_elite.nsc, paired=FALSE);
t.test(results.merged$F5_elite.sc, results.merged$F5_elite.nsc, paired=FALSE);
```

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=6, fig.height=5, fig.cap="Comparing the effects of scaled and non-scaled input on the learned vowel formants."}
# Plots:
results.scaled <- rbind(cbind("input.scaled"="scaled",     results.scaled),
                        cbind("input.scaled"="non-scaled", results.nonscaled));
levels(results.scaled$vowel) <- c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]");

ggplot(results.scaled, aes(x=F2_elite, y=F1_elite, shape=vowel, fill=input.scaled, color=input.scaled)) + 
  scale_y_reverse() + scale_x_reverse() + xlab("F2") + ylab("F1") +
  geom_point(alpha=0.25, size=1.5) + 
  scale_shape_manual(values=21:25) + scale_fill_manual(name="input", values=c("red","blue")) + scale_color_manual(name="input", values=c("red","blue"));
ggplot(results.scaled, aes(x=F2_elite, y=F3_elite, shape=vowel, fill=input.scaled, color=input.scaled)) + 
  scale_y_reverse() + scale_x_reverse() + xlab("F2") + ylab("F3") +
  geom_point(alpha=0.25, size=1.5) + 
  scale_shape_manual(values=21:25) + scale_fill_manual(name="input", values=c("red","blue")) + scale_color_manual(name="input", values=c("red","blue"));
```

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=5, fig.height=10, fig.cap="Boxplots of the elite formants by vowel comparing input scaling."}
# Long format:
results.scaled.long <- melt(results.scaled, 
                            id.vars=c("input.scaled", "vowel", "replication"),
                            measure.vars=c("F1_elite", "F2_elite", "F3_elite", "F4_elite", "F5_elite",
                                           "F1.error", "F2.error", "F3.error", "F4.error", "F5.error",
                                           "HX_elite", "HY_elite", "JA_elite", "LP_elite", "LD_elite", "TCX_elite", "TCY_elite", "TTX_elite", "TTY_elite", "TBX_elite", "TBY_elite", 
                                           "generation"),
                            variable.name="variable", value.name="value");

ggplot(results.scaled.long[results.scaled.long$variable %in% c("F1_elite","F2_elite","F3_elite","F4_elite","F5_elite"),], 
                            aes(x=vowel, y=value, color=input.scaled)) + 
  geom_boxplot() + scale_color_discrete(name="input") +
  facet_grid(variable ~ ., scales="free_y", 
             labeller=labeller(variable = c("F1_elite"="F1", "F2_elite"="F2", "F3_elite"="F3", "F4_elite"="F4", "F5_elite"="F5")));
```

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=5, fig.height=10, fig.cap="Boxplots of the elite formant errors by vowel comparing input scaling."}
ggplot(results.scaled.long[results.scaled.long$variable %in% c("F1.error","F2.error","F3.error","F4.error","F5.error"),], 
                            aes(x=vowel, y=value, color=input.scaled)) + 
  geom_boxplot() + scale_color_discrete(name="input") +
  facet_grid(variable ~ ., scales="free_y", 
             labeller=labeller(variable = c("F1.error"="F1err", "F2.error"="F2err", "F3.error"="F3err", "F4.error"="F4err", "F5.error"="F5err")));
```

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=9, fig.height=6, fig.cap="Scaled by non-scaled elite formant values per vowel."}
par(mfrow=c(2,3));
plot.new();
legend("center", legend=c("[ə]", "[ɑ]", "[æ]", "[i]", "[u]"), title="Vowel colors", col=cols4vowels2D, pch=16);

plot(results.merged$F1_elite.sc, results.merged$F1_elite.nsc, xlab="F1 (scaled)", ylab="F1 (non-scaled)", pch=16, col=cols4vowels2D[as.character(results.merged$vowel)]);
abline(v=unique(results.merged$F1_target.sc), lty="dotted", col="gray"); abline(h=unique(results.merged$F1_target.sc), lty="dotted", col="gray");

plot(results.merged$F2_elite.sc, results.merged$F2_elite.nsc, xlab="F2 (scaled)", ylab="F2 (non-scaled)", pch=16, col=cols4vowels2D[as.character(results.merged$vowel)]);
abline(v=unique(results.merged$F2_target.sc), lty="dotted", col="gray"); abline(h=unique(results.merged$F2_target.sc), lty="dotted", col="gray");

plot(results.merged$F3_elite.sc, results.merged$F3_elite.nsc, xlab="F3 (scaled)", ylab="F3 (non-scaled)", pch=16, col=cols4vowels2D[as.character(results.merged$vowel)]);
abline(v=unique(results.merged$F3_target.sc), lty="dotted", col="gray"); abline(h=unique(results.merged$F3_target.sc), lty="dotted", col="gray");

plot(results.merged$F4_elite.sc, results.merged$F4_elite.nsc, xlab="F4 (scaled)", ylab="F4 (non-scaled)", pch=16, col=cols4vowels2D[as.character(results.merged$vowel)]);
abline(v=unique(results.merged$F4_target.sc), lty="dotted", col="gray"); abline(h=unique(results.merged$F4_target.sc), lty="dotted", col="gray");

plot(results.merged$F5_elite.sc, results.merged$F5_elite.nsc, xlab="F5 (scaled)", ylab="F5 (non-scaled)", pch=16, col=cols4vowels2D[as.character(results.merged$vowel)]);
abline(v=unique(results.merged$F5_target.sc), lty="dotted", col="gray"); abline(h=unique(results.merged$F5_target.sc), lty="dotted", col="gray");
```
  






